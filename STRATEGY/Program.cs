
using STRATEGY;

class Program
{
    static void Main()
    {

        #region Описание

        // Под Стратегией здесь понимается некий набор (или семейство) схожих алгоритмов, которые помещаются (инкапсулируются) в классе, и могут потом взаимозаменяться во время исполнения программы
        // В зависимости от ситуации мы можем заменить один другим, при этом замена может произойти совершенно независимо от объекта, который алгоритм использует.

        /*Когда используем? 

        У нас есть несколько похожих родственных классов, отличающихся поведением. Тогда мы можем сделать один основной класс, а эти различающиеся варианты поведения вынести в отдельные классы, и применять по мере необходимости.
        У нас есть несколько вариантов алгоритмов, которые мы можем менять в зависимости от условий.
        Во время выполнения программы нам нужно менять поведение объектов.
        Класс, в котором определен функционал, не должен ничего знать о реализации.*/

        #endregion 

        #region

        // 1) Сначала задаем общий интерфейс алгоритма (при желании также можно использовать и абстрактный класс): interface IStrategy
        // 2) Добавим реализации: class StrategyOne и class StrategyTwo

        #endregion

        IStrategy strategy1 = new StrategyOne();
        Client client = new Client(strategy1);
        client.ExecuteAlgorithm();

        IStrategy strategy2 = new StrategyTwo();
        client = new Client(strategy2);
        client.ExecuteAlgorithm();

    }
}