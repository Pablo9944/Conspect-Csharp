
class Program
{
    static void Main()
    {
        #region Описание
        // S - single Responsibility Principle
        /*  У класса должна быть только одна причина для изменения.
            Под обязанностью мы тут подразумеваем те функции, которые решает ваш класс, или задачу вашего класса. 
            Суть в том, что задача у класса должна быть одна. Вы не должны пытаться добавить в ваш класс то, для чего он изначально не создавался просто потому, что так удобно. Лучше в этом случае создать отдельный класс.
            Если же вам понадобилось расширить функционал класса дополнительными функциями (но они всё равно выполняют ту цель, для которой класс создавался), то проблем нет, принцип в данном случае не нарушается.*/

        // O - open/Closed Principle
        /*Сущности программы должны быть открыты для расширения, но закрыты для модификации.
          Иначе говоря, вы должны проектировать классы так, чтобы при необходимости их можно было легко дополнить (то есть оставлять задел на будущее, возможности для масштабирования и роста функционала).
          При разработке стоит по возможности закладывать необходимый минимум функционала, и иметь в виду, что в дальнейшем он будет расширен, а то, что уже работает не сломается.*/

        // L - liskov Substitution Principle
        /*Цель в том, чтобы подклассы могли бы служить заменой своих базовых классов. При соблюдении этого принципа мы можем использовать классы-наследники вместо родительских классов, и работа программы не будет нарушена. 
          Если мы видим, что в коде идёт проверка на тип класса, то данный принцип нарушен. Код в этом случае стоит переписать так, чтобы не завязываться на конкретный тип.*/

        // I - interface Segregation Principle
        /*Рекомендуется по возможности создавать узко-специализированные интерфейсы, чтобы не тащить в классы излишний функционал, который, вероятнее всего, реализован не будет.
          Стоит по возможности разделять интерфейс класса на отдельные части. Позже вы сможете применять и изменять их независимо друг от друга. Следование этому принципу делает систему слабо связанной, и её проще поддерживать и обновлять.*/

        // D - dependency Inversion Principle
        /*Объектом зависимости должна быть абстракция, а не что-то конкретное. 
          Абстракция (интерфейс — самый распространенный пример) не должна зависеть от деталей реализации. Наоборот, реализация должна зависеть от абстракции.*/
        #endregion
    }
}