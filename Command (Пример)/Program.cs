

using Command__Пример_;

class Program
{
    static void Main()
    {
        #region Описание

        /*Итак, когда используем?

        Нам надо передать в виде параметров какие-то действия, и в ответ мы должны получить другие действия. То есть нам нужно получить обратный ответ.
        Нам нужна очередь запросов, а также возможность их отмены.
        Нам нужно контролировать изменения в логах и отслеживать поведение нашей системы. Это нам также поможет восстановить систему в случае сбоев.*/


        /*Тот, кто отправляет команду (в нашем случае это класс Sender) ничего не знает о получателе Receiver, выполняющем команду. Мы также с легкостью можем добавить новые команды, унаследовав базовый класс Command.
        Этот паттерн на C# имеет очень широкое применение в масштабных приложениях уровня enterprise. В будущем вы наверняка столкнетесь с ним при разработке API-сервисов и других .NET Core-приложений.  
        Очень часто они имеют структуру из нескольких слоев, один из которых может отвечать за пользовательский интерфейс, другой — за бизнес-логику, а третий — за взаимодействие с данными.
        Общаться между собой при этом слои могут как раз с помощью команд.*/

        #endregion

        #region Описание действий

        // 1) Зададим общий интерфейс команды: abstract class Command
        // 2) Теперь зададим класс отправителя с методами для отправки и отмены команд: class Sender
        // 3) Класс-получатель команды: class Receiver
        // 4) Реализуем класс команды. Таких реализаций (как и команд, соответственно) в одном приложении может быть множество: class CommandOne
        #endregion

        // создадим отправителя
        var sender = new Sender();

        // создадим получателя
        var receiver = new Receiver();

        // создадим команду
        var commandOne = new CommandOne(receiver);

        // инициализация команды
        sender.SetCommand(commandOne);

        //  выполнение
        sender.Run();
    }
}